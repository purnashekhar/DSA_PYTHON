

# ðŸ“˜ **ARRAYS â€” Complete**

## **1. What is an Array?**

An **array** is a collection of elements stored at **continuous memory locations**, accessed using an **index**.

In Python, the closest structure to an array is a **List**.

Example:

```python
arr = [10, 20, 30, 40]
```

---

# **2. Why Arrays Matter in DSA**

* Fast access (O(1) indexing)
* Used in **two pointers**, **prefix sum**, **searching**, **sorting**, **sliding window**
* Most interview problems start with arrays
* Foundation for strings, hashing, stack, queue

---

# **3. Basic Operations (Python List)**

Below are the operations and their time complexity (important in DSA).

### âœ” Access element

```python
arr[i]
```

âž¡ **O(1)**

### âœ” Update element

```python
arr[i] = 50
```

âž¡ **O(1)**

---

# **4. List Methods in Python (What You Must Know)**

### âž¤ **1. append() â€” add at end**

```python
arr.append(x)
```

âž¡ **O(1)** average

### âž¤ **2. pop() â€” remove last element**

```python
arr.pop()
```

âž¡ **O(1)**

### âž¤ **3. insert() â€” insert at index**

```python
arr.insert(i, x)
```

âž¡ **O(n)** (shifts elements)

### âž¤ **4. remove() â€” remove by value**

```python
arr.remove(x)
```

âž¡ **O(n)** (search + shift)

### âž¤ **5. del â€” delete by index**

```python
del arr[i]
```

âž¡ **O(n)** (shift)

### âž¤ **6. slicing**

```python
arr[1:4]
```

âž¡ **O(k)** where k = slice length

### âž¤ **7. length**

```python
len(arr)
```

âž¡ **O(1)**

---

# **5. How Arrays Work Internally**

* Stored in **continuous blocks of memory**
* Python lists are **dynamic arrays**

  * They grow automatically when needed
  * Expansion uses *amortized O(1)* resizing

This is why `append()` is fast most of the time.

---

# **6. Types of Arrays (Conceptual)**

### âœ” Static Array

* Fixed size
* In languages like C/C++
* Python does NOT have this

### âœ” Dynamic Array (Python List)

* Can grow/shrink
* Real implementation used in Python

---

# **7. Traversing an Array**

Traversing = visiting each element.

### Normal loop:

```python
for x in arr:
    print(x)
```

âž¡ **O(n)**

### Using index:

```python
for i in range(len(arr)):
    print(arr[i])
```

âž¡ **O(n)**

---

# **8. Searching in Arrays**

### âž¤ **Linear Search**

Check all elements.

```python
for x in arr:
    if x == target:
        return True
```

âž¡ **O(n)**

### âž¤ **Binary Search (only sorted array)**

Divide & conquer.
âž¡ **O(log n)**

(You will learn this in Searching module.)

---

# **9. Array Memory Indexing**

If array = `[10, 20, 30, 40]`

| Index | Value |
| ----- | ----- |
| 0     | 10    |
| 1     | 20    |
| 2     | 30    |
| 3     | 40    |

Indexing always starts at **0**.

---

# **10. Array Slicing (Important in Python)**

```python
arr[start:end]     # end is non-inclusive
arr[:3]            # first 3 elements
arr[2:]            # from index 2 to end
arr[::-1]          # reverse array
```

Very useful in problems.

---

# **11. Common Array Patterns (Used in DSA)**

These patterns are used in almost **50%** of array problems.

### âœ” Frequency array / Hashmap

Count occurrences of each element.

### âœ” Prefix sum

Fast range queries
`prefix[i] = sum(arr[0..i])`

### âœ” Two pointers

Left & right pointer approach.

### âœ” Sliding window

Fixed-size or variable-size windows for subarray problems.

### âœ” Sorting arrays

For optimum solutions in many problems.

---

# **12. Time Complexities To Memorize**

| Operation          | Big-O          |
| ------------------ | -------------- |
| Access element     | O(1)           |
| Update element     | O(1)           |
| Append at end      | O(1) amortized |
| Insert at index    | O(n)           |
| Delete at index    | O(n)           |
| Loop through array | O(n)           |
| Nested loops       | O(nÂ²)          |

---

# **13. Space Complexity with Arrays**

### âœ” No extra array â†’ O(1)

```python
for i in arr:
```

### âœ” Creating new array â†’ O(n)

```python
new_arr = arr[:]
```

### âœ” Extra prefix/hash arrays â†’ O(n)

---

# **14. When to Use Arrays**

Use arrays when:

* You need fast access
* You need to traverse repeatedly
* Order matters
* Working with numbers, strings, dates, objects

Not ideal when:

* Frequent insertions/deletions in the middle â†’ use deque instead

---

# ðŸŽ‰ **Arrays â€” Complete Summary (For Quick Revision)**

* Python list = dynamic array
* Access/update = O(1)
* Insert/delete in middle = O(n)
* append/pop end = O(1)
* Traversing = O(n)
* Used in 80% of DSA basic problems
* Base for two pointers, sliding window, prefix sum, searching & sorting

---


